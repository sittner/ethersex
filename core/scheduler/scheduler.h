/*
 * scheduler/scheduler.h
 *
 * Copyright (c) 2013-2015 by Michael Brakemeier <michael@brakemeier.de>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 3
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * For more information on the GPL, please go to:
 * http://www.gnu.org/copyleft/gpl.html
 */

#ifndef SCHEDULER_H_
#define SCHEDULER_H_

#include <stdint.h>

#ifdef DEBUG_SCHEDULER_SUPPORT
#include "core/debug.h"
#define SCHEDULERDEBUG(a...)    debug_printf("scheduler: " a)
#else
#define SCHEDULERDEBUG(a...)
#endif /* DEBUG_SCHEDULER_SUPPORT */

/**
 * Return values for the scheduler functions.
 */
#define SCHEDULER_OK    0       /* Everything fine */
#define SCHEDULER_ERR   -1      /* Some error occurred */
#define SCHEDULER_AGAIN -2      /* Resource temporarily unavailable, e.g. no timer slot free */
#define SCHEDULER_INVAL -3      /* invalid argument, e.g. referenced timer_t func not found */

/**
 * Maximum value for timer interval
 */
#define SCHEDULER_INTERVAL_MAX  UINT16_MAX

/* Timer/Task states */
#define TIMER_DELETED   0x00
#define TIMER_SUSPENDED 0x01
#define TIMER_RUNNABLE  0x02
#define TIMER_RUNNING   0x04
/* reserved 0x08 */
#define TIMER_ONESHOT   0x10
/* reserved 0x20 */
/* reserved 0x40 */
/* reserved 0x80 */

/**
 * typedef "timer_t as pointer to function (void) returning void" (from cdecl.org :-)
 */
typedef void (*timer_t)(void);

/**
 * static timer control block structure
 */
// put const data into PROGMEM
typedef struct {
  timer_t       timer;
  uint16_t      interval;
} static_timer_func_t;

typedef struct {
  uint16_t      delay;
  uint8_t       state;
} static_timer_cb_t;

/**
 * dynamic timer control block structure
 */
typedef struct {
  timer_t       timer;
  uint16_t      delay;
  uint16_t      interval;
  uint8_t       state;
} dynamic_timer_cb_t;

/*
 * All the static timers in one array (in PROGMEM), generated by meta_magic_scheduler.m4
 */
extern const static_timer_func_t scheduler_static_timers[];

/*
 * All the static timer control blocks one array (in RAM), generated by meta_magic_scheduler.m4
 */
extern static_timer_cb_t scheduler_static_timers_control[];

/*
 * Max. number of static timers in timer array, generated by meta_magic_scheduler.m4.
 */
extern const uint8_t scheduler_static_timer_max;

#ifdef SCHEDULER_DYNAMIC_SUPPORT
/*
 * All the dynamic timer control blocks one array (in RAM)
 */
extern dynamic_timer_cb_t scheduler_dynamic_timers[];

/*
 * Max. number of static timers in timer array, generated by meta_magic_scheduler.m4.
 */
extern const uint8_t scheduler_dynamic_timer_max;

#endif /* SCHEDULER_DYNAMIC_SUPPORT */

/**
 * The scheduler loop.
 */
void scheduler_dispatch_timer(void);

/**
 * 'Millitick' the scheduler.
 *
 * This function will be inlined into the periodic ISR.
 * Keep it SHORT and simple.
 *
 * We definitely want to inline all millitickers.
 */
__attribute__((always_inline)) static inline void scheduler_tick(void)
{
  uint8_t i;

  for(i = 0; i < scheduler_static_timer_max; i++)
  {
    /* check for runnable static timer with delay greater zero (to prevent underflow in
     * case a timer could not be dispatched in time.
     */
    if((scheduler_static_timers_control[i].state & TIMER_RUNNABLE) && (scheduler_static_timers_control[i].delay > 0))
    {
      scheduler_static_timers_control[i].delay--;
    }
  }

#ifdef SCHEDULER_DYNAMIC_SUPPORT
  for(i = 0; i < scheduler_dynamic_timer_max; i++)
  {
    /* check for runnable dynamic timer with delay greater zero (to prevent underflow in
     * case a timer could not be dispatched in time.
     */
    if((scheduler_dynamic_timers[i].state & TIMER_RUNNABLE) && (scheduler_dynamic_timers[i].delay > 0))
    {
      scheduler_dynamic_timers[i].delay--;
    }
  }
#endif /* SCHEDULER_DYNAMIC_SUPPORT */

  return;
}

#endif /* SCHEDULER_H_ */
